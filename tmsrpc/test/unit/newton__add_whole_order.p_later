/**
 * This is the test set for the corresponding newton__add_whole_order
 * XML RPC method.
 *
 * The fixture usage of this test set:
 *
 * - fixtures fetched: 
 *
 * - The RPC method is assumed to fetch in addition following records:
 *
 *
 * - restrictions for building other fixtures: 
 */

{timestamp.i}
{includes/dbutils.i}

{test_xmlrpc_includes.i}

/* /apps/xfera/harrim/tmsrpc/test/unit/c */

{unit/checkutils.i}

/* Fixture tables used */
gcFixtures = "msisdn,order,OrderTopup,SIM,ordercustomer,memo,clitype".

/* Identifier for the parameter array */
DEF VAR gcParamArray     AS CHAR NO-UNDO.
DEF VAR gcOrderStruct    AS CHAR NO-UNDO.
DEF VAR gcCustomerStruct AS CHAR NO-UNDO.
DEF VAR gcAddressStruct  AS CHAR NO-UNDO.
DEF VAR gcContactStruct  AS CHAR NO-UNDO.
DEF VAR gcDeviceStruct   AS CHAR NO-UNDO.
DEF VAR gcServiceArray   AS CHAR NO-UNDO.


DEF VAR lLogOn AS LOGICAL NO-UNDO. 
lLogOn = FALSE.


/* Expected response values */
{unit/newton__add_whole_order_variable_defs.i} 

FUNCTION fLog RETURN LOGICAL (INPUT pcMsg AS CHARACTER):
   IF lLogOn THEN MESSAGE pcMsg.
   RETURN TRUE.
END.


/** 
 * This function calls the RPC method and checks the call succeeds.
 */
FUNCTION call_add_whole_order RETURN LOGICAL:
    fLog("before call...").
    run_rpc_method("newton.add_whole_order").
    fLog("end call... ").
    RETURN TRUE.
END FUNCTION.




FUNCTION fAddMaxOrderParamStruct RETURN LOGICAL:
   fLog("adding max order param struct...").
   add_string(   gcOrderStruct,"billing_data"        ,gcExpectedAccount).
   add_string(   gcOrderStruct,"campaign_code"       ,gcExpectedCampaign).
   add_string(   gcOrderStruct,"channel"             ,gcExpectedParamChannel).
   add_boolean(  gcOrderStruct,"check"               ,glExpectedCheck).
   add_string(   gcOrderStruct,"CLI"                 ,gcExpectedCLI).
   add_string(   gcOrderStruct,"company_id"          ,gcExpectedCompanyId).
   add_string(   gcOrderStruct,"contractid"          ,gcExpectedContractID).
   add_double(   gcOrderStruct,"fat"                 ,gdeExpectedFAT).
   add_string(   gcOrderStruct,"ICC"                 ,gcExpectedICC).
/*   add_string(   gcOrderStruct,"id_type"             ,gcExpectedParamIdType). */
   add_string(   gcOrderStruct,"memo"                ,gcExpectedMemoText).
   add_boolean(  gcOrderStruct,"mnp_process_bypass"  ,glExpectedMnpProcessBypass).
   add_boolean(  gcOrderStruct,"network_bypass"      ,glExpectedNetworkBypass).
   add_boolean(  gcOrderStruct,"no_charge"           ,glExpectedNoCharge).
   add_string(   gcOrderStruct,"number_type"         ,gcExpectedNumberType).
   add_string(   gcOrderStruct,"old_billing_category",gcExpectedOldBillCategory).
   add_string(   gcOrderStruct,"old_icc"             ,gcExpectedOldICC).
   add_string(   gcOrderStruct,"old_operator"        ,gcExpectedCurrOper).
   add_string(   gcOrderStruct,"orderer_ip"          ,gcExpectedOrdererIp).
   
  

   add_string(   gcOrderStruct,"payment_method"      ,gcExpectedPaymentMethod).
   add_string(   gcOrderStruct,"payment_reference"   ,gcExpectedCCReference).
/*   add_string(   gcOrderStruct,"person_id"           ,gcExpectedPersonId). */
   add_string(   gcOrderStruct,"salesman"            ,gcExpectedSalesman).
   /* add_string(   gcOrderStruct,"services"            ,gcExpectedServices). */

/*   MESSAGE "OrderStruct.subscription_type " gcExpectedSubscriptionType VIEW-AS ALERT-BOX. */

   add_string(   gcOrderStruct,"subscription_type"   ,gcExpectedSubscriptionType). 
   add_double(   gcOrderStruct,"topup"               ,gdeExpectedTopup).
   add_string(   gcOrderStruct,"user_fname"          ,gcExpectedUserFName).
   add_string(   gcOrderStruct,"user_lname"          ,gcExpectedUserLName).
   add_string(   gcOrderStruct,"user_lname2"         ,gcExpectedUserLName2).

   RETURN TRUE.
END.

FUNCTION fAddMinOrderParamStruct RETURN LOGICAL: 
   fLog("adding min order param struct...").
   add_string( gcOrderStruct,"channel"           ,gcExpectedChannel).  
   add_string( gcOrderStruct,"CLI"               ,gcExpectedCLI). 
   add_string( gcOrderStruct,"contractid"        ,gcExpectedContractID).
   add_string( gcOrderStruct,"id_type"           ,gcExpectedParamIdType).
   add_string( gcOrderStruct,"orderer_ip"        ,gcExpectedOrdererIp).

   fLog("OrderStruct.subscription_type" + gcExpectedCLIType).
   add_string( gcOrderStruct,"subscription_type" ,gcExpectedCLIType).
/*   gcParamServiceArray = add_array(gcParamOrderStruct, "services"). */
END.



FUNCTION fAddMaxCustomerParamStruct RETURN LOGICAL
    (INPUT plExpectedPersonID AS LOGICAL, INPUT plExpectedCompanyID AS LOGICAL):
   fLog("adding max customer param struct...").
   add_datetime( gcCustomerStruct,"birthday"            ,DATETIME( gdaExpectedBirthDay ,0 )).
   add_string(   gcCustomerStruct,"city"                ,gcExpectedPostOffice).
   add_string(   gcCustomerStruct,"id_type"             ,gcExpectedParamIdType).
/*   add_string(   gcCustomerStruct,"coname"              ,gcExpectedCoName). */
/*   add_string(   gcCustomerStruct,"contact_name"        ,gcExpectedOrderer). */
   add_string(   gcCustomerStruct,"street_code"                ,gcExpectedCodC).
   add_string(   gcCustomerStruct,"city_code"                ,gcExpectedCodP).
   add_string(   gcCustomerStruct,"country"             ,gcExpectedCountry).
   add_string(   gcCustomerStruct,"email"               ,gcExpectedEmail).
   add_string(   gcCustomerStruct,"fname"               ,gcExpectedFName).
   add_string(   gcCustomerStruct,"language"            ,gcExpectedParamLanguage).
   add_string(   gcCustomerStruct,"lName"               ,gcExpectedLName).
   add_string(   gcCustomerStruct,"lName2"              ,gcExpectedLName2).
   add_boolean(  gcCustomerStruct,"mark_email"          ,glExpectedMarkEmail).
   add_boolean(  gcCustomerStruct,"mark_email_3rd"      ,glExpectedMarkEmail3rd).
   add_boolean(  gcCustomerStruct,"mark_post"           ,glExpectedMarkPost).
   add_boolean(  gcCustomerStruct,"mark_post_3rd"       ,glExpectedMarkPost3rd).
   add_boolean(  gcCustomerStruct,"mark_sms"            ,glExpectedMarkSMS).
   add_boolean(  gcCustomerStruct,"mark_sms_3rd"        ,glExpectedMarkSMS3rd).
   add_string(   gcCustomerStruct,"nationality"         ,gcExpectedNationality).
   add_string(   gcCustomerStruct,"phone_number"        ,gcExpectedFixedNumber).
   add_string(   gcCustomerStruct,"region"              ,gcExpectedRegion).
   add_string(   gcCustomerStruct,"site_name"           ,gcExpectedCompany).
   add_string(   gcCustomerStruct,"sms_number"          ,gcExpectedSMSNumber).
   add_string(   gcCustomerStruct,"street"              ,gcExpectedAddress).
   add_string(   gcCustomerStruct,"title"               ,gcExpectedTitle).
   add_string(   gcCustomerStruct,"zip"                 ,gcExpectedZipCode).

   /* Either personID or companyID must exist */
   IF plExpectedPersonID THEN
   DO:
      add_string( gcCustomerStruct, "person_id"     , gcExpectedPersonID).
   END.
   IF plExpectedCompanyID THEN
   DO:
      add_string( gcCustomerStruct, "company_id"    , gcExpectedCompanyID).
   END.

   RETURN TRUE.
END.


FUNCTION fAddMinCustomerParamStruct RETURN LOGICAL
    (INPUT plExpectedPersonID AS LOGICAL, INPUT plExpectedCompanyID AS LOGICAL):

   fLog("adding min param struct...").
   add_string( gcCustomerStruct,"city"   ,gcExpectedPostOffice).
   add_string( gcCustomerStruct,"street" ,gcExpectedAddress).
   add_string( gcCustomerStruct,"zip"    ,gcExpectedZipCode).

   /* Either personID or companyID must exist */
   IF plExpectedPersonID THEN
   DO:
      add_string( gcCustomerStruct, "person_id"     , gcExpectedPersonID).
   END.
   IF plExpectedCompanyID THEN
   DO:
      add_string( gcCustomerStruct, "company_id"    , gcExpectedCompanyID).
   END.

   RETURN TRUE.
END.


FUNCTION fAddMaxAddressParamStruct RETURN LOGICAL: 
   fLog("AddMaxAddressParam").
   add_datetime( gcAddressStruct,"birthDay"      ,DATETIME( gdaExpectedAddressBirthDay ,0 )).
   add_string(   gcAddressStruct,"city"          ,gcExpectedAddressCity).
/*   add_string(   gcAddressStruct,"coname"        ,gcExpectedAddressConame). */
/*   add_string(   gcAddressStruct,"contact_name"  ,gcExpectedAddressContactName). */
   add_string(   gcAddressStruct,"city_code"          ,gcExpectedAddressCodC).
   add_string(   gcAddressStruct,"street_code"          ,gcExpectedAddressCodP).
   add_string(   gcAddressStruct,"country"       ,gcExpectedAddressCountry).
   add_string(   gcAddressStruct,"customer_name" ,gcExpectedAddressCustomerName).
   add_string(   gcAddressStruct,"email"         ,gcExpectedAddressEmail).
   add_string(   gcAddressStruct,"fname"         ,gcExpectedAddressFName).
   add_string(   gcAddressStruct,"language"      ,gcExpectedAddressParamLanguage).
   add_string(   gcAddressStruct,"lname"         ,gcExpectedAddressLName).
   add_string(   gcAddressStruct,"lname2"        ,gcExpectedAddressLName2).
   add_boolean(  gcAddressStruct,"mark_email"    ,glExpectedAddressMarkEmail).
   add_boolean(  gcAddressStruct,"mark_email_3rd",glExpectedAddressMarkEmail3rd).
   add_boolean(  gcAddressStruct,"mark_post"     ,glExpectedAddressMarkPost).
   add_boolean(  gcAddressStruct,"mark_post_3rd" ,glExpectedAddressMarkPost3rd).
   add_boolean(  gcAddressStruct,"mark_sms"      ,glExpectedAddressMarkSMS).
   add_boolean(  gcAddressStruct,"mark_sms_3rd"  ,glExpectedAddressMarkSMS3rd).
   add_string(   gcAddressStruct,"nationality"   ,gcExpectedAddressNationality).
   add_string(   gcAddressStruct,"phone_number"  ,gcExpectedAddressPhoneNumber).
   add_string(   gcAddressStruct,"region"        ,gcExpectedAddressRegion).
   add_string(   gcAddressStruct,"site_name"     ,gcExpectedAddressSiteName).
   add_string(   gcAddressStruct,"sms_number"    ,gcExpectedAddressSmsNumber).
   add_string(   gcAddressStruct,"street"        ,gcExpectedAddressStreet).
   add_string(   gcAddressStruct,"title"         ,gcExpectedAddressTitle).
   add_string(   gcAddressStruct,"zip"           ,gcExpectedAddressZip).
   RETURN TRUE.
END.


FUNCTION fAddMinAddressParamStruct RETURN LOGICAL:
   fLog("adding min address param struct... ").
   add_string( gcAddressStruct,"city"   ,gcExpectedAddressCity).
   add_string( gcAddressStruct,"street" ,gcExpectedAddressStreet).
   add_string( gcAddressStruct,"zip"    ,gcExpectedAddressZip).
   RETURN TRUE.
END.




FUNCTION fAddMaxContactParamStruct RETURN LOGICAL: 
   fLog("AddMaxContactParamStruct").
   add_datetime( gcContactStruct,"birthDay"      ,DATETIME( gdaExpectedContactBirthDay ,0 )).
   add_string(   gcContactStruct,"city"          ,gcExpectedContactCity).
/* add_string(   gcContactStruct,"coname"        ,gcExpectedContactConame). */
/* add_string(   gcContactStruct,"contact_name"  ,gcExpectedContactContactName). */
   add_string(   gcContactStruct,"city_code"          ,gcExpectedContactCodC).
   add_string(   gcContactStruct,"street_code"          ,gcExpectedContactCodP).
   add_string(   gcContactStruct,"country"       ,gcExpectedContactCountry).
   add_string(   gcContactStruct,"customer_name" ,gcExpectedContactCustomerName).
   add_string(   gcContactStruct,"email"         ,gcExpectedContactEmail).
   add_string(   gcContactStruct,"fname"         ,gcExpectedContactFName).
   add_string(   gcContactStruct,"language"      ,gcExpectedContactParamLanguage).
   add_string(   gcContactStruct,"lname"         ,gcExpectedContactLName).
   add_string(   gcContactStruct,"lname2"        ,gcExpectedContactLName2).
   add_boolean(  gcContactStruct,"mark_email"    ,glExpectedContactMarkEmail).
   add_boolean(  gcContactStruct,"mark_email_3rd",glExpectedContactMarkEmail3rd).
   add_boolean(  gcContactStruct,"mark_post"     ,glExpectedContactMarkPost).
   add_boolean(  gcContactStruct,"mark_post_3rd" ,glExpectedContactMarkPost3rd).
   add_boolean(  gcContactStruct,"mark_sms"      ,glExpectedContactMarkSMS).
   add_boolean(  gcContactStruct,"mark_sms_3rd"  ,glExpectedContactMarkSMS3rd).
   add_string(   gcContactStruct,"nationality"   ,gcExpectedContactNationality).
   add_string(   gcContactStruct,"phone_number"  ,gcExpectedContactPhoneNumber).
   add_string(   gcContactStruct,"region"        ,gcExpectedContactRegion).
   add_string(   gcContactStruct,"site_name"     ,gcExpectedContactSiteName).
   add_string(   gcContactStruct,"sms_number"    ,gcExpectedContactSmsNumber).
   add_string(   gcContactStruct,"street"        ,gcExpectedContactStreet).
   add_string(   gcContactStruct,"title"         ,gcExpectedContactTitle).
   add_string(   gcContactStruct,"zip"           ,gcExpectedContactZip).
   RETURN TRUE.
END.


FUNCTION fAddMinContactParamStruct RETURN LOGICAL:
   fLog("AddMinContactParamStruct").
   add_string( gcContactStruct,"city"           ,gcExpectedContactCity).
   add_string( gcContactStruct,"street"         ,gcExpectedContactStreet).
   add_string( gcContactStruct,"zip"            ,gcExpectedContactZip).
   add_string( gcContactStruct,"fname"          ,gcExpectedContactFName).
   add_string( gcContactStruct,"lname"          ,gcExpectedContactLName).
   add_string( gcContactStruct,"region"         ,gcExpectedContactRegion).
/*   add_string( gcContactStruct,"id_type"        ,gcExpectedContactIdType).   /* ?! Order params ? */
   add_string( gcContactStruct,"person_id"      ,gcExpectedContactPersonId). /* ?! */ */
   add_string( gcContactStruct,"title"          ,gcExpectedContactTitle).
   add_string( gcContactStruct,"sms_number"     ,gcExpectedContactSmsNumber).
   add_string( gcContactStruct,"email"          ,gcExpectedContactEmail).
   add_int( gcContactStruct,"language"          ,giExpectedContactLanguage).
   add_string( gcContactStruct,"nationality"    ,gcExpectedContactNationality).
   RETURN TRUE.
END.




FUNCTION fAddMaxDeviceParamStruct RETURN LOGICAL:
   fLog("adding max device param struct...").
   add_string( gcDeviceStruct,"device_model",gcExpectedDeviceModel).
   add_double( gcDeviceStruct,"device_price",gdeExpectedDevicePrice).
   add_double( gcDeviceStruct,"discount"    ,gdeExpectedDiscount).
/*   add_string( gcDeviceStruct,"IMEI"        ,gcExpectedParamIMEI). */
   RETURN TRUE.
END.


FUNCTION fCheckTimeStamp RETURN LOGICAL (
   INPUT pcDbTableField AS CHARACTER,
   INPUT pdeVal1 AS DECIMAL, INPUT pdeVal2 AS DECIMAL):
   fLog("checkTimeStamp").

   DEFINE VARIABLE iVal1 AS INTEGER NO-UNDO. 
   DEFINE VARIABLE iVal2 AS INTEGER NO-UNDO. 
   DEFINE VARIABLE deDiff AS DECIMAL NO-UNDO. 
   iVal1 = INTEGER(TRUNCATE(pdeVal1,0)).
   iVal2 = INTEGER(TRUNCATE(pdeVal2,0)).
   deDiff = pdeVal1 - pdeVal2.

   /* The gap between first second in the following day and the last second
      in the previous day is taken off before comparison */
   IF iVal1 ne iVal2 THEN deDiff = deDiff - 13600.    

   /* Difference of minute is allowed so that time stamps won't differ between 
      the time when call returns and the time when RPC was called. */
   IF deDiff <= 60 THEN RETURN TRUE. ELSE 
   DO:
      assert(FALSE, "Error comparing time stamp field " + pcDbTableField).

      RETURN FALSE.
   END.
END.


FUNCTION fCheckOrderMaxParam RETURN LOGICAL (INPUT piExpOrderID AS INTEGER,
   INPUT pcBrand AS CHARACTER):
   FIND Order WHERE Order.OrderID = piExpOrderID AND Order.Brand = pcBrand 
      NO-LOCK NO-ERROR.
   IF NOT AVAILABLE Order THEN
      assert(TRUE, "Expected Order record was not found in the database.").
   ELSE
   DO:
      fLog("CheckOrderMaxParam").


      FIND OrderPayment WHERE OrderPayment.Brand = "1" AND OrderPayment.OrderId = piExpOrderId NO-LOCK NO-ERROR.
      IF AVAIL OrderPayment THEN MESSAGE "OrderPayment.Method = " OrderPayment.Method VIEW-AS ALERT-BOX.


      checkChar(   "Order.Brand"        ,Order.Brand        ,gcExpectedBrand).
      checkChar(   "Order.Campaign"     ,Order.Campaign     ,gcExpectedCampaign).

/*      MESSAGE "asdhasjkdhjk,,asd....." VIEW-AS ALERT-BOX. */

      checkChar(   "Order.OrderChannel" ,Order.OrderChannel ,gcExpectedChannel).

/*      MESSAGE "sdcfsdjkhfjk.,.sdd....asdad.." VIEW-AS ALERT-BOX. */

      checkChar(   "Order.CLI"          ,Order.CLI          ,gcExpectedCLI).
      checkChar(   "Order.CLIType"      ,Order.CLIType      ,gcExpectedSubscriptionType).
      checkChar(   "Order.ContractID"   ,Order.ContractID   ,gcExpectedContractID).
      checkChar(   "Order.CurrOper"     ,Order.CurrOper     ,gcExpectedCurrOper).
      checkChar(   "Order.DeviceID"     ,Order.DeviceID     ,gcExpectedDeviceId).

      /* checkChar(   "Order.DeviceID"     ,Order.DeviceID     ,gcExpectedDeviceModel). */

      checkChar(   "Order.FeeModel"     ,Order.FeeModel     ,gcExpectedFeeModel).

/*      MESSAGE "sjkdj.qw.e..qwe.." VIEW-AS ALERT-BOX. */

      checkChar(   "Order.ICC"          ,Order.ICC          ,gcExpectedICC).
      checkChar(   "Order.OldICC"       ,Order.OldICC       ,gcExpectedOldICC).
/*      checkChar(   "Order.Orderer"      ,Order.Orderer      ,gcExpectedOrderer). */
      checkChar(   "Order.OrdererId"    ,Order.OrdererId    ,gcExpectedOrdererID).
      checkChar(   "Order.OrdererIdType",Order.OrdererIdType,gcExpectedOrdererIdType).
      checkChar(   "Order.OrdererIp"    ,Order.OrdererIp    ,gcExpectedOrdererIp).
      checkChar(   "Order.Source"       ,Order.Source       ,gcExpectedSource).
      checkChar(   "Order.statuscode"   ,Order.statuscode   ,gcExpectedStatusCode).
      fCheckTimeStamp("Order.CrStamp"   ,Order.CrStamp      ,gdeExpectedCreStamp).
      checkDecimal("Order.FAT"          ,Order.FAT          ,gdeExpectedFAT).
      checkInt(    "Order.InvCustRole"  ,Order.InvCustRole  ,giExpectedInvCustrole).
      checkInt(    "Order.mnpstatus"    ,Order.mnpstatus    ,giExpectedMnpStatus).
/*      MESSAGE "hedsdfkskdsadasdasd..asd..asd.." VIEW-AS ALERT-BOX. */

      checkInt(    "Order.msseq"        ,Order.msseq        ,giExpectedMsSeq).

/*      MESSAGE "werjbcmnbuyetvuyfioksdjfhvsdi..sdsf" VIEW-AS ALERT-BOX. */
      checkInt(    "Order.OrderID"      ,Order.OrderID      ,giExpectedOrderId).
      checkInt(    "Order.UserRole"     ,Order.UserRole     ,giExpectedUserRole).
      checkLogical("Order.OldPayType"   ,Order.OldPayType   ,
                   glExpectedOldPayType,'glExpectedOldPayType did not match.').
      checkLogical("Order.Paytype"      ,Order.Paytype      ,
                   glExpectedPayType,'glExpectedPayType did not match.').

   END. 
   RETURN TRUE.
END.


FUNCTION fCheckOrderCustomerBiggerMaxParam RETURN LOGICAL 
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
     
/*   MESSAGE "Brand:" + pcBrand + ",RowType: " + STRING(piRowType) 
           + ",OrderID: " + STRING(piOrderID) VIEW-AS ALERT-BOX. */

   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Customer OrderCustomer record was not found in the database.").
   ELSE
   DO:
/*      MESSAGE "CheckOrderCustomerBiggerMaxParam" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.BankCode",OrderCustomer.BankCode ,
             gcExpectedAccount ).
      checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedAddress ).

      checkChar( "OrderCustomer.Brand",OrderCustomer.Brand,
             gcExpectedBrand).
      checkChar( "OrderCustomer.Company",OrderCustomer.Company,
             gcExpectedCompany ).
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId ).
/*      MESSAGE "DSADJK" VIEW-AS ALERT-BOX.
      checkChar( "OrderCustomer.SurName2",OrderCustomer.SurName2 ,
             gcExpectedCoName).
      MESSAGE "sdjfsdklj" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.country",OrderCustomer.country,
             gcExpectedCountry ).
      checkChar( "OrderCustomer.CodC"   ,OrderCustomer.AddressCodC,
             gcExpectedCodC ).
      checkChar( "OrderCustomer.CodP"   ,OrderCustomer.AddressCodP,
             gcExpectedCodP ).
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustID).
      checkChar( "OrderCustomer.CustIDType",OrderCustomer.CustIDType,
             gcExpectedCustIDType).
      checkChar( "OrderCustomer.email",OrderCustomer.email,
             gcExpectedEmail).
      checkChar( "OrderCustomer.FixedNumber",OrderCustomer.FixedNumber ,
             gcExpectedFixedNumber ).
      checkChar( "OrderCustomer.FirstName",OrderCustomer.FirstName,
             gcExpectedFName).
      checkChar( "OrderCustomer.Surname1",OrderCustomer.Surname1 ,
             gcExpectedLName).
      checkChar( "OrderCustomer.Surname2",OrderCustomer.Surname2 ,
             gcExpectedLName2).
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedSMSNumber).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedNationality ).
/*      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedPersonId). */
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId). 
      checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedPostOffice).
      checkChar( "OrderCustomer.region",OrderCustomer.region ,
             gcExpectedRegion).
      checkChar( "OrderCustomer.Language",OrderCustomer.Language ,
             gcExpectedLanguage).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedNationality ).
/*             gcExpectedSecOrdCustNational ). */
      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedCountry ).
/*      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedSecOrdCustrCountry ). */
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedSMSNumber ).
      checkChar( "OrderCustomer.custtitle",OrderCustomer.custtitle,
             gcExpectedTitle).
      checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedZipCode ).
      checkDate( "OrderCustomer.BirthDay",OrderCustomer.BirthDay ,
             gdaExpectedBirthDay ).
/*      checkInt( "OrderCustomer.RowType",OrderCustomer.RowType,
             giExpectedRowType ). */
      checkLogical("OrderCustomer.OperEmailMarketing",OrderCustomer.OperEmailMarketing,
             glExpectedMarkEmail ,'glExpectedMarkEmail did not match.').
      checkLogical("OrderCustomer.OutEmailMarketing",OrderCustomer.OutEmailMarketing ,
             glExpectedMarkEmail3rd,'glExpectedMarkEmail3rd did not match.').
      checkLogical("OrderCustomer.OperPostMarketing",OrderCustomer.OperPostMarketing ,
             glExpectedMarkPost,'glExpectedMarkPost did not match.').
      checkLogical("OrderCustomer.OutPostMarketing",OrderCustomer.OutPostMarketing,
             glExpectedMarkPost3rd ,'glExpectedMarkPost3rd did not match.').
      checkLogical("OrderCustomer.OperSMSMarketing",OrderCustomer.OperSMSMarketing,
             glExpectedMarkSMS ,'glExpectedMarkSMS did not match.').
      checkLogical("OrderCustomer.OutSMSMarketing",OrderCustomer.OutSMSMarketing ,
             glExpectedMarkSMS3rd,'glExpectedMarkSMS3rd did not match.').
/*      checkLogical("OrderCustomer.OperAllMarketing",OrderCustomer.OperAllMarketing,
             glExpectedOperAllMarketing ,'glExpectedOperAllMarketing did not match.'). */
   END.
   RETURN TRUE.
END.



FUNCTION fCheckOrderCustomerMinParam RETURN LOGICAL
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
      
   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Address OrderCustomer record was not found in the database.").
   ELSE
   DO:
       checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedZipCode ).
       checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedAddress ).
       checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedPostOffice).
       /* Empty or default values in other fields */
   END.
END.



FUNCTION fCheckAddressOrderCustomerMaxParam RETURN LOGICAL
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
      
   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Address OrderCustomer record was not found in the database.").
   ELSE
   DO:
/*      MESSAGE "CheckOrderCustomerBiggerMaxParam" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.BankCode",OrderCustomer.BankCode ,
             gcExpectedAccount ). 
      checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedAddressStreet ).

      checkChar( "OrderCustomer.Brand",OrderCustomer.Brand,
             gcExpectedBrand).
      checkChar( "OrderCustomer.Company",OrderCustomer.Company,
             gcExpectedCustId ).
/*      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId ). */
/*      MESSAGE "DSADJK" VIEW-AS ALERT-BOX.
      checkChar( "OrderCustomer.SurName2",OrderCustomer.SurName2 ,
             gcExpectedAddressCoName).
      MESSAGE "sdjfsdklj" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.country",OrderCustomer.country,
             gcExpectedAddressCountry ).
      checkChar( "OrderCustomer.CodC"   ,OrderCustomer.AddressCodC,
             gcExpectedAddressCodC ).
      checkChar( "OrderCustomer.CodP"   ,OrderCustomer.AddressCodP,
             gcExpectedAddressCodP ).
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustID). 
      checkChar( "OrderCustomer.CustIDType",OrderCustomer.CustIDType,
             gcExpectedCustIDType). 
      checkChar( "OrderCustomer.email",OrderCustomer.email,
             gcExpectedAddressEmail).
      checkChar( "OrderCustomer.FixedNumber",OrderCustomer.FixedNumber ,
             gcExpectedAddressPhoneNumber ).
      checkChar( "OrderCustomer.FirstName",OrderCustomer.FirstName,
             gcExpectedAddressFName).
      checkChar( "OrderCustomer.Surname1",OrderCustomer.Surname1 ,
             gcExpectedAddressLName).
      checkChar( "OrderCustomer.Surname2",OrderCustomer.Surname2 ,
             gcExpectedAddressLName2).
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedAddressSMSNumber).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedAddressNationality ).
/*      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedAddressPersonId). */
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId). 
      checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedAddressCity).
      checkChar( "OrderCustomer.region",OrderCustomer.region ,
             gcExpectedAddressRegion).
      checkChar( "OrderCustomer.Language",OrderCustomer.Language ,
             STRING(giExpectedAddressLanguage) ).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedAddressNationality ).
/*             gcExpectedSecOrdCustNational ). */
      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedAddressCountry ).
/*      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedSecOrdCustrCountry ). */
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedAddressSMSNumber ).
      checkChar( "OrderCustomer.custtitle",OrderCustomer.custtitle,
             gcExpectedAddressTitle).
      checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedAddressZip ).
      checkDate( "OrderCustomer.BirthDay",OrderCustomer.BirthDay ,
             gdaExpectedAddressBirthDay ).
/*      checkInt( "OrderCustomer.RowType",OrderCustomer.RowType,
             giExpectedRowType ). */
      checkLogical("OrderCustomer.OperEmailMarketing",OrderCustomer.OperEmailMarketing,
             glExpectedAddressMarkEmail ,'glExpectedAddressMarkEmail did not match.').
      checkLogical("OrderCustomer.OutEmailMarketing",OrderCustomer.OutEmailMarketing ,
             glExpectedAddressMarkEmail3rd,'glExpectedAddressMarkEmail3rd did not match.').
      checkLogical("OrderCustomer.OperPostMarketing",OrderCustomer.OperPostMarketing ,
             glExpectedAddressMarkPost,'glExpectedAddressMarkPost did not match.').
      checkLogical("OrderCustomer.OutPostMarketing",OrderCustomer.OutPostMarketing,
             glExpectedAddressMarkPost3rd ,'glExpectedAddressMarkPost3rd did not match.').
      checkLogical("OrderCustomer.OperSMSMarketing",OrderCustomer.OperSMSMarketing,
             glExpectedAddressMarkSMS ,'glExpectedAddressMarkSMS did not match.').
      checkLogical("OrderCustomer.OutSMSMarketing",OrderCustomer.OutSMSMarketing ,
             glExpectedAddressMarkSMS3rd,'glExpectedAddressMarkSMS3rd did not match.').
/*      checkLogical("OrderCustomer.OperAllMarketing",OrderCustomer.OperAllMarketing,
             glExpectedOperAllMarketing ,'glExpectedOperAllMarketing did not match.'). */




/*
/*      MESSAGE "CheckOrderCustomerSmallerMaxParam" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.Language",OrderCustomer.Language ,
                 gcExpectedSecOrdCustLanguage ).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
                 gcExpectedSecOrdCustNational ).
      checkChar( "OrderCustomer.country",OrderCustomer.country,
                 gcExpectedSecOrdCustrCountry ).
      checkChar( "OrderCustomer.Address",OrderCustomer.Address,
                 gcExpectedAddressStreet ).
/*      MESSAGE "heresmallerpostoffice" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
                 gcExpectedAddressCity ).
      checkChar( "OrderCustomer.AddressCodC", OrderCustomer.AddressCodC,
                 gcExpectedAddressCodC ).
      checkChar( "OrderCustomer.AddressCodP", OrderCustomer.AddressCodP,
                 gcExpectedAddressCodP ).
/*      MESSAGE "hereasdgadg" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.FirstName",OrderCustomer.FirstName,
                 gcExpectedAddressFName ).
      checkChar( "OrderCustomer.Surname1",OrderCustomer.Surname1 ,
                 gcExpectedAddressLName ).
      checkChar( "OrderCustomer.Surname2",OrderCustomer.Surname2 ,
                 gcExpectedAddressLName2 ).
      checkChar( "OrderCustomer.ZipCode", OrderCustomer.ZipCode,
                 gcExpectedAddressZip ).

*/
    END.
    RETURN TRUE.
END.


FUNCTION fCheckAddressOrderCustomerMinParam RETURN LOGICAL
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
      
   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Address OrderCustomer record was not found in the database.").
   ELSE
   DO:
       checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedAddressZip ).
       checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedAddressStreet ).
       checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedAddressCity).
       /* Empty or default values in other fields */
   END.
END.



FUNCTION fCheckContactOrderCustomerMaxParam RETURN LOGICAL
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
      
   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Contact OrderCustomer record was not found in the database.").
   ELSE
   DO:
/*      MESSAGE "CheckContactOrderCustomerMaxParam" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.BankCode",OrderCustomer.BankCode ,
             gcExpectedAccount ).
      checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedContactStreet ).

      checkChar( "OrderCustomer.Brand",OrderCustomer.Brand,
             gcExpectedBrand).
      checkChar( "OrderCustomer.Company",OrderCustomer.Company,
             gcExpectedCustId ).
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId ).
/*      MESSAGE "DSADJK" VIEW-AS ALERT-BOX.
      checkChar( "OrderCustomer.SurName2",OrderCustomer.SurName2 ,
             gcExpectedContactCoName).
      MESSAGE "sdjfsdklj" VIEW-AS ALERT-BOX. */
      checkChar( "OrderCustomer.country",OrderCustomer.country,
             gcExpectedContactCountry ).
      checkChar( "OrderCustomer.CodC"   ,OrderCustomer.AddressCodC,
             gcExpectedContactCodC ).
      checkChar( "OrderCustomer.CodP"   ,OrderCustomer.AddressCodP,
             gcExpectedContactCodP ).
/*      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedContactCustID). */
      checkChar( "OrderCustomer.CustIDType",OrderCustomer.CustIDType,
             gcExpectedCustIDType).
      checkChar( "OrderCustomer.email",OrderCustomer.email,
             gcExpectedContactEmail).
      checkChar( "OrderCustomer.FixedNumber",OrderCustomer.FixedNumber ,
             gcExpectedContactPhoneNumber ).
      checkChar( "OrderCustomer.FirstName",OrderCustomer.FirstName,
             gcExpectedContactFName).
      checkChar( "OrderCustomer.Surname1",OrderCustomer.Surname1 ,
             gcExpectedContactLName).
      checkChar( "OrderCustomer.Surname2",OrderCustomer.Surname2 ,
             gcExpectedContactLName2).
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedContactSMSNumber).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedContactNationality ).
/*      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedContactContactPersonId). */
      checkChar( "OrderCustomer.CustID",OrderCustomer.CustID ,
             gcExpectedCustId). 
      checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedContactCity).
      checkChar( "OrderCustomer.region",OrderCustomer.region ,
             gcExpectedContactRegion).
      checkChar( "OrderCustomer.Language",OrderCustomer.Language ,
             STRING(giExpectedContactLanguage) ).
      checkChar( "OrderCustomer.Nationality",OrderCustomer.Nationality ,
             gcExpectedContactNationality ).
/*             gcExpectedContactSecOrdCustNational ). */
      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedContactCountry ).
/*      checkChar( "OrderCustomer.Country",OrderCustomer.Country,
             gcExpectedContactSecOrdCustrCountry ). */
      checkChar( "OrderCustomer.MobileNumber",OrderCustomer.MobileNumber,
             gcExpectedContactSMSNumber ).
      checkChar( "OrderCustomer.custtitle",OrderCustomer.custtitle,
             gcExpectedContactTitle).
      checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedContactZip ).
      checkDate( "OrderCustomer.BirthDay",OrderCustomer.BirthDay ,
             gdaExpectedContactBirthDay ).
/*      checkInt( "OrderCustomer.RowType",OrderCustomer.RowType,
             giExpectedContactRowType ). */
      checkLogical("OrderCustomer.OperEmailMarketing",OrderCustomer.OperEmailMarketing,
             glExpectedContactMarkEmail ,'glExpectedContactMarkEmail did not match.').
      checkLogical("OrderCustomer.OutEmailMarketing",OrderCustomer.OutEmailMarketing ,
             glExpectedContactMarkEmail3rd,'glExpectedContactMarkEmail3rd did not match.').
      checkLogical("OrderCustomer.OperPostMarketing",OrderCustomer.OperPostMarketing ,
             glExpectedContactMarkPost,'glExpectedContactMarkPost did not match.').
      checkLogical("OrderCustomer.OutPostMarketing",OrderCustomer.OutPostMarketing,
             glExpectedContactMarkPost3rd ,'glExpectedContactMarkPost3rd did not match.').
      checkLogical("OrderCustomer.OperSMSMarketing",OrderCustomer.OperSMSMarketing,
             glExpectedContactMarkSMS ,'glExpectedContactMarkSMS did not match.').
      checkLogical("OrderCustomer.OutSMSMarketing",OrderCustomer.OutSMSMarketing ,
             glExpectedContactMarkSMS3rd,'glExpectedContactMarkSMS3rd did not match.').
/*      checkLogical("OrderCustomer.OperAllMarketing",OrderCustomer.OperAllMarketing,
             glExpectedOperAllMarketing ,'glExpectedOperAllMarketing did not match.'). */
   END.
   RETURN TRUE.
END.



FUNCTION fCheckContactOrderCustomerMinParam RETURN LOGICAL
    (INPUT piOrderID AS INTEGER, INPUT piRowType AS INTEGER,
     INPUT pcBrand AS CHARACTER):
   FIND FIRST OrderCustomer WHERE 
      OrderCustomer.Brand = pcBrand AND 
      OrderCustomer.RowType = piRowType AND
      OrderCustomer.OrderID = piOrderID NO-LOCK NO-ERROR.
      
   IF NOT AVAILABLE OrderCustomer THEN
      assert(TRUE, "Expected Address OrderCustomer record was not found in the database.").
   ELSE
   DO:
       checkChar( "OrderCustomer.ZIP",OrderCustomer.ZIP,
             gcExpectedContactZip ).
       checkChar( "OrderCustomer.Address",OrderCustomer.Address,
             gcExpectedContactStreet ).
       checkChar( "OrderCustomer.PostOffice",OrderCustomer.PostOffice,
             gcExpectedContactCity).
       /* Empty or default values in other fields */
   END.
END.



FUNCTION fCheckMemo RETURN LOGICAL (INPUT piMemoSeq AS INTEGER, 
   INPUT piMemoType AS INTEGER):
   FIND FIRST Memo WHERE MemoSeq = piMemoSeq NO-LOCK NO-ERROR.
   IF NOT AVAILABLE Memo THEN
   DO:
      assert(TRUE, "Expected Memo record with MemoSeq = " + STRING(piMemoSeq) + 
                   " of type " + STRING(piMemoType) +
                   " was not found in the database.").
   END.
   ELSE
   DO:
/*      MESSAGE "CheckMemo" VIEW-AS ALERT-BOX. */
      checkChar( "Memo.Brand"    , Memo.Brand    , gcExpectedBrand ).
      checkChar( "Memo.HostTable", Memo.HostTable, gcExpectedHostTable ).
      checkChar( "Memo.KeyValue" ,Memo.KeyValue  , gcExpectedKeyValue ).
      IF piMemoType = 1 THEN
      DO:
         checkChar( "Memo.MemoTitle", Memo.MemoTitle, gcExpectedMemoTitle ).
         checkChar( "Memo.CreUser"  , Memo.CreUser  , gcExpectedCreUser ).
         checkChar( "Memo.MemoText" , Memo.MemoText , gcExpectedMemoText).
      END.
      ELSE IF piMemoType = 2 THEN
      DO:
         checkChar( "Memo.MemoTitle", Memo.MemoTitle, gcExpectedMemoTitle2 ).
         checkChar( "Memo.CreUser"  , Memo.CreUser  , gcExpectedCreUser2 ).
         checkChar( "Memo.MemoText" , Memo.MemoText , gcExpectedMemoText2 ).
      END.
      ELSE IF piMemoType = 3 THEN
      DO:
         checkChar( "Memo.MemoTitle", Memo.MemoTitle, gcExpectedMemoTitle3 ).
         checkChar( "Memo.CreUser"  , Memo.CreUser  , gcExpectedCreUser ).
         checkChar( "Memo.MemoText" , Memo.MemoText , gcExpectedMemoText3 ).
      END.
      fCheckTimeStamp( "Memo.CreStamp", Memo.CreStamp, gdeExpectedCreStamp ).
   END.
   RETURN TRUE.
END.


FUNCTION fCheckNotMemoType RETURN LOGICAL (INPUT piMemoSeq AS INTEGER,
   INPUT piMemoType AS INTEGER):
   
   FIND FIRST Memo WHERE MemoSeq = piMemoSeq NO-LOCK NO-ERROR.
   IF NOT AVAILABLE Memo THEN
   DO:
      RETURN TRUE. /* Not found is no error */
   END.
   ELSE
   DO:
      IF piMemotype = 1 THEN
      DO:
         assert(Memo.MemoTitle ne "Info", 
            "First type of Memo record encountered with MemoSeq " + STRING(piMemoSeq) + 
            " although there should not come one.").
      END.
      ELSE
      DO:
         assert(Memo.MemoTitle = "Info", 
            "Second type of Memo record encountered with MemoSeq " + STRING(piMemoSeq) + 
            " although there should not come one.").
      END.
   END.
END.    


FUNCTION fCheckSIM RETURN LOGICAL (INPUT pcICC AS CHARACTER):
   FIND FIRST SIM WHERE 
      SIM.Brand = "1" AND SIM.ICC = pcICC AND SIM.SimStat = 4 NO-LOCK NO-ERROR.
   IF AVAILABLE SIM THEN
   DO:
      assert_equal_int(SIM.Simstat,   giExpectedSIMStatus ).
   END.
   RETURN TRUE.
END.

FUNCTION fCheckMsisdn RETURN LOGICAL (INPUT pcBrand AS CHARACTER, INPUT pcCLI AS CHARACTER):
   FIND FIRST MSISDN WHERE MSISDN.Brand = pcBrand AND MSISDN.CLI = pcCLI NO-LOCK NO-ERROR.
   IF NOT AVAILABLE MSISDN THEN
      assert(TRUE, "Expected MSISDN with CLI = " + pcCLI + " was not found in the database.").
   ELSE
   DO:
/*      checkChar(   "MSISDN.statuscode",MSISDN.statuscode,gcExpectedMsisdnStatusCode). */
      checkInt(    "msisdn.statuscode",msisdn.statuscode,giExpectedStatusCode).
      assert_equal_int( msisdn.statuscode,
                giExpectedStatusCode).
      assert_equal_int( msisdn.orderid ,
                giExpectedOrderId ).
   END.
   RETURN TRUE.
END.


FUNCTION fCheckOrderAccessory RETURN LOGICAL
   (INPUT piOrderID AS INTEGER, INPUT pcBrand AS CHARACTER):

   FIND FIRST OrderAccessory WHERE 
      OrderAccessory.Brand = pcBrand AND
      OrderAccessory.OrderID = piOrderID NO-LOCK NO-ERROR.
   IF NOT AVAILABLE OrderAccessory THEN
   DO:
      assert(TRUE, "Expected OrderAccessory record was not found in the database.").
   END.
   ELSE
   DO:
/*      MESSAGE "CheckOrderAccessory" VIEW-AS ALERT-BOX. */
      assert_equal_double(OrderAccessory.Amount     , gdeExpectedDevicePrice).
      assert_equal_char(  OrderAccessory.ProductCode, gcExpectedDeviceModel ).
      assert_equal_char(  OrderAccessory.IMEI       , gcExpectedIMEI ).
      assert_equal_double(OrderAccessory.discount   , gdeExpectedDiscount).
   END.
   RETURN TRUE.
END.



FUNCTION  fCheckOrderPayment RETURN LOGICAL
   (INPUT pcBrand AS CHARACTER, INPUT piOrderID AS INTEGER):

    FIND FIRST OrderPayment WHERE OrderPayment.Brand = pcBrand AND
                                  OrderPayment.OrderID = piOrderID 
                                  NO-LOCK NO-ERROR.
    IF NOT AVAILABLE OrderPayment THEN
       assert(TRUE, "Expected OrderPayment record was not found in the database.").
    ELSE
    DO:
       fLog("CheckOrderPayment").
       assert_equal_char(OrderPayment.Brand      , gcExpectedBrand).
       fLog("1").
       assert_equal_char(OrderPayment.CCReference, gcExpectedCCReference ).
       fLog("2").
       checkInt(    "OrderPayment.Method"      ,OrderPayment.Method      ,giExpectedMethod).


/*       assert_equal_int( OrderPayment.Method     , giExpectedMethod ). */
       MESSAGE "3" VIEW-AS ALERT-BOX.
    END.
    RETURN TRUE.
END.



FUNCTION fCheckOrderTopup RETURN LOGICAL
   (INPUT pcBrand AS CHARACTER, INPUT piOrderID AS INTEGER):

   FIND FIRST OrderTopup WHERE OrderTopup.Brand = pcBrand AND
                               OrderTopup.OrderID = piOrderID NO-LOCK NO-ERROR.
   IF NOT AVAILABLE OrderTopup THEN
      assert(TRUE, "The expected OrderTopup record was not found in the database.").
   ELSE
   DO:
/*      MESSAGE "CheckOrderTopup" VIEW-AS ALERT-BOX. */
      assert_equal_double( OrderTopup.Amount, gdeExpectedTopup ).
   END.
   RETURN TRUE.
END.


FUNCTION fCheckNotUpdatedSIM RETURN LOGICAL (INPUT pcICC AS CHARACTER, 
   INPUT piRound AS INTEGER):
   FIND FIRST SIM WHERE SIM.ICC = pcICC NO-LOCK NO-ERROR.
   IF AVAILABLE SIM THEN
   DO:
      IF SIM.simstat = 4 THEN
         assert(TRUE, "SIM with ICC " + pcICC + 
                " should not be updated to status 4 in round " + STRING(piRound)).
   END.
   RETURN TRUE.
END.

FUNCTION fCheckNotUpdatedMSISDN RETURN LOGICAL (INPUT pcCLI AS CHARACTER, 
    INPUT piRound AS INTEGER):
    FIND FIRST MSISDN WHERE MSISDN.CLI = pcCLI NO-LOCK NO-ERROR.
    IF AVAILABLE MSISDN THEN
    DO:
       IF MSISDN.statuscode = 2 AND MSISDN.orderid = giExpectedOrderId THEN
          assert(TRUE, "MSISDN with CLI " + pcCLI + 
          " should not be updated in round " + STRING(piRound)).
    END.
    RETURN TRUE.
END.



FUNCTION fCheckNotExistentOrderPayment RETURN LOGICAL (INPUT piRound AS INTEGER):
   FIND FIRST OrderPayment WHERE OrderPayment.Brand = gcExpectedBrand AND
                                 OrderPayment.OrderID = giExpectedOrderID 
                                 NO-LOCK NO-ERROR.
   assert(NOT AVAILABLE OrderPayment, "Unexpected OrderPayment existed in round " +
          STRING(piRound) + " and with orderID " + STRING(giExpectedOrderID)).
   RETURN TRUE.
END.


FUNCTION fCheckNotExistingOrderAccessory RETURN LOGICAL (INPUT piRound AS INTEGER):
   assert(NOT AVAILABLE OrderAccessory, "Unexpected OrderAccessory existed in round " +
          STRING(piRound) + " and with OrderID " + STRING(giExpectedOrderID)). 
   RETURN TRUE.
END.

FUNCTION fCheckNotExistingOrderTopup RETURN LOGICAL (INPUT piRound AS INTEGER):
   assert(NOT AVAILABLE OrderTopup, "Unexpected OrderTopup existed in round " +
          STRING(piRound) + " and with OrderID " + STRING(giExpectedOrderID)). 
   RETURN TRUE.
END.


FUNCTION fCheckResponse RETURN LOGICAL (INPUT piRound AS INTEGER):
  fLog("before Order Max Param check....").

  IF piRound = 9 THEN 
  DO:
/*     MESSAGE "round 9, extra order accessory test2" VIEW-AS ALERT-BOX. */
     fCheckOrderAccessory(giExpectedOrderID, "1").
     fCheckOrderPayment("1", giExpectedOrderID).
/*     MESSAGE "round 9 extra test end..." VIEW-AS ALERT-BOX. */
  END.
  fCheckOrderMaxParam(giExpectedOrderID, "1"). 
/*  MESSAGE "before OrderCustomer Max Param check" VIEW-AS ALERT-BOX.  */
  fCheckOrderCustomerBiggerMaxParam(giExpectedOrderId, 1, "1").
/*  MESSAGE "before smaller OrderCustomer Max Param check" VIEW-AS ALERT-BOX. */
  fCheckAddressOrderCustomerMaxParam(giExpectedOrderId, 4, "1").
/*  MESSAGE "after check smaller OrderCustomer Max Param" VIEW-AS ALERT-BOX.  */
  fCheckContactOrderCustomerMaxParam(giExpectedOrderId, 5, "1").


  IF piRound MODULO 2 = 1 THEN
  DO:
     /* Must be first memo */
     fCheckMemo(giExpectedMemoSeq, 1).
     fLog("after check memo").
     giExpectedMemoSeq = giExpectedMemoSeq + 1. 
  END.
  ELSE
  DO:
     fCheckNotMemoType(giExpectedMemoSeq, 1).
     fLog("after check not memo").
  END.

  DEFINE VARIABLE iRoundMemo2Modulo AS INTEGER NO-UNDO. 
  iRoundMemo2Modulo = piRound MODULO 21.

  IF glExpectedCheck THEN
  DO:
      fCheckMemo(giExpectedMemoSeq, 3).
      fLog("after check memo 2").
  END.

  IF (iRoundMemo2Modulo >= 4 AND iRoundMemo2Modulo <= 6) OR
      iRoundMemo2Modulo = 7 OR iRoundMemo2Modulo = 10 OR
      iRoundMemo2Modulo = 13 THEN
  DO:
     fCheckMemo(giExpectedMemoSeq, 2).
     fLog("after check memo3").
  END.
  ELSE
  DO:
     fCheckNotMemoType(giExpectedMemoSeq, 2).
     fLog("after check not memo2").
  END.

/*  MESSAGE "After Memo check" VIEW-AS ALERT-BOX. */

  IF iRoundMemo2Modulo < 8 OR iRoundMemo2Modulo = 10 OR 
     iRoundMemo2Modulo = 11 OR iRoundMemo2Modulo = 14 THEN      
  DO:
     fCheckNotExistentOrderPayment(piRound).
     fLog("after check not OrderPayment").
  END.
  ELSE
  DO:
     fCheckOrderPayment("1", giExpectedOrderID).
     fLog("after check OrderPayment").
  END.

/*  MESSAGE "After OrderPayment check" VIEW-AS ALERT-BOX. */


  IF iRoundMemo2Modulo < 11 THEN
  DO:
     fCheckNotExistingOrderAccessory(piRound).
     fLog("after check no OrderAccessory").
  END.
  ELSE
  DO:
     fCheckOrderAccessory(giExpectedOrderID, "1").
     fLog("After check OrderAccessory").
  END.

/*  MESSAGE "After OrderAccessory check" VIEW-AS ALERT-BOX. */

  IF piRound MODULO 3 = 1 THEN
  DO:
     fCheckNotExistingOrderTopup(piRound).
     fLog("After check no OrderTopup").
  END.
  ELSE
  DO:
     fCheckOrderTopup("1", giExpectedOrderID).
     fLog("After check OrderTopup").
  END.

/*  MESSAGE "After OrderTopup check" VIEW-AS ALERT-BOX. */

  IF iRoundMemo2Modulo = 17 THEN
  DO:
     fCheckSIM(gcExpectedICC).
     fLog("After Check SIM").
  END.
  ELSE
  DO:
     fCheckNotUpdatedSIM(gcExpectedICC, piRound).
     fLog("After check no SIM").
  END.

/*  MESSAGE "After SIM check" VIEW-AS ALERT-BOX. */

  IF iRoundMemo2Modulo = 0 THEN
  DO:
     fCheckMsisdn("1", gcExpectedCLI).
     fLog("After check MSISDN").
  END.
  ELSE
  DO:
     fCheckNotUpdatedMSISDN(gcExpectedCLI, piRound).
     fLog("After check no MSISDN").
  END.
  RETURN TRUE.
END.


FUNCTION fDispDescription RETURN LOGICAL (INPUT piRound AS INTEGER):
   DEFINE VARIABLE iTestDescChar AS INTEGER NO-UNDO. 
   DEFINE VARIABLE iTestDescNextComma AS INTEGER NO-UNDO. 
   DEFINE VARIABLE iTestDescNextPeriod AS INTEGER NO-UNDO. 
   iTestDescChar = 1.
   DEFINE VARIABLE iDescLength AS INTEGER NO-UNDO. 

   fLog("-----------------------------------------").
   fLog("Description of the round " + STRING(piRound)).

/*   RETURN TRUE. */

   fLog("-----------------------------------------").
   iDescLength = LENGTH(gcExpectedTestDescription).
/*   MESSAGE STRING(iDescLength) VIEW-AS ALERT-BOX. */
   DO WHILE iTestDescChar < LENGTH(gcExpectedTestDescription):
/*     MESSAGE STRING(iTestDescChar) VIEW-AS ALERT-BOX. */
      iTestDescNextComma = INDEX(gcExpectedTestDescription, ",", iTestDescChar).
      iTestDescNextPeriod = INDEX(gcExpectedTestDescription, ".", iTestDescChar).
/*     MESSAGE "iTestDescNextComma: " + STRING(iTestDescNextComma) +
              ",iTestDescNextPeriod: " + STRING(iTestDescNextPeriod) +
              ",iTestDescChar: " + STRING(iTestDescChar) 
              VIEW-AS ALERT-BOX. */
      DEFINE VARIABLE iOldTestDescChar AS INTEGER NO-UNDO. 
      iOldTestDescChar = iTestDescChar.
      IF iTestDescNextComma = 0 AND iTestDescNextPeriod = 0 THEN
      DO:
          fLog("  " + SUBSTRING(gcExpectedTestDescription, iTestDescChar, 
             LENGTH(gcExpectedTestDescription) - iTestDescChar - 1)).
             iTestDescChar = LENGTH(gcExpectedTestDescription).
      END.
      ELSE IF iTestDescNextComma = 0 THEN
      DO:
          fLog("  " + SUBSTRING(gcExpectedTestDescription, iTestDescChar,
             iTestDescNextPeriod - iTestDescChar )).
             iTestDescChar = iTestDescNextPeriod + 1.
      END.
      ELSE IF iTestDescNextPeriod = 0 THEN
      DO:
         fLog("  " + SUBSTRING(gcExpectedTestDescription, iTestDescChar,
            iTestDescNextComma - iTestDescChar )).
            iTestDescChar = iTestDescNextComma + 1.
      END.
      ELSE IF iTestDescNextComma > iTestDescNextPeriod THEN
      DO:
         fLog("  " + SUBSTRING(gcExpectedTestDescription, iTestDescChar,
            iTestDescNextPeriod - iTestDescChar )).
            iTestDescChar = iTestDescNextPeriod + 1.
      END.
      ELSE
      DO:
         fLog("  " + SUBSTRING(gcExpectedTestDescription, iTestDescChar,
            iTestDescNextComma - iTestDescChar )).
            iTestDescChar = iTestDescNextComma + 1.
      END. 
      IF iTestDescChar = iOldTestDescChar THEN 
         iTestDescChar = iTestDescChar + 1.
   END. 
   fLog("-----------------------------------------").
   RETURN Yes.
END.


FUNCTION fAddStructs RETURN LOGICAL:
   gcOrderStruct    = add_struct("", "0").
   gcCustomerStruct = add_struct("", "1").
   gcAddressStruct  = add_struct("", "2").
   gcDeviceStruct   = add_struct("", "3").
   gcContactStruct  = add_struct("", "4").
   RETURN TRUE.
END.


FUNCTION fAddStructData RETURN LOGICAL ( INPUT iRound AS INTEGER ):
   fLog("begin fAddStructData").
   IF iRound <= 20 THEN
   DO:
      fLog("before param").
      fAddMaxOrderParamStruct().
/*      MESSAGE "after order param" VIEW-AS ALERT-BOX.  */
      fAddMaxCustomerParamStruct(TRUE, TRUE).
/*      MESSAGE "after customer param" VIEW-AS ALERT-BOX.  */
      fAddMaxAddressParamStruct().
/*      MESSAGE "after address param" VIEW-AS ALERT-BOX. */
      fAddMaxContactParamStruct().
      IF iRound = 9 THEN
      DO:
         fAddMaxDeviceParamStruct().
/*         MESSAGE "after device param" VIEW-AS ALERT-BOX. */
      END.
   END.
   ELSE
   DO:
      fAddMinOrderParamStruct().
      CASE iRound:
         WHEN 21 THEN fAddMinCustomerParamStruct(TRUE, FALSE).
         WHEN 22 THEN fAddMinCustomerParamStruct(FALSE, TRUE).
         WHEN 23 THEN fAddMinCustomerParamStruct(FALSE, FALSE).
      END.
      fAddMinAddressParamStruct().
      fAddMinContactParamStruct().
      /* Device is empty: optional situations tested with max param functions */
   END.
/*   MESSAGE "end fAddStructData" VIEW-AS ALERT-BOX. */
END.

FUNCTION fCheckResult RETURN LOGICAL (INPUT piRound AS INTEGER):
/*   MESSAGE "Begin fCheckResult" VIEW-AS ALERT-BOX. */
   DEFINE VARIABLE iRoundModulo AS INTEGER NO-UNDO. 
   iRoundModulo = piRound MODULO 20.
   IF iRoundModulo >= 1 AND iRoundModulo <= 3 THEN
   DO:
/*      MESSAGE "here .---- near application error ------ ..." VIEW-AS ALERT-BOX. 
         assert_fault({&APPLICATION_ERROR}, 
         SUBST("Cli &1 not found or not free", gcExpectedCLI)).  */
/*      MESSAGE "sdfsdkljfsdkljf" VIEW-AS ALERT-BOX. */
   END.
   ELSE IF iRoundModulo = 18 OR iRoundModulo = 19 THEN
   DO:
      fLog("SIM application error expected").
      assert_fault({&APPLICATION_ERROR}, 
         SUBST("SIM with ICC &1 not found or not free", gcExpectedICC)).
   END.
   ELSE IF iRoundModulo = 20 THEN
   DO:
      fLog("device application error expected").
      assert_fault({&APPLICATION_ERROR}, 
         "add_item device,but neither device_model nor IMEI given"). 
   END.
   ELSE IF iRoundModulo = 23 THEN
   DO:
      fLog("no identification error expected").
      assert_fault({&APPLICATION_ERROR}, 
         "Expected either person_id or company_id").
   END.
   ELSE
   DO:
/*      MESSAGE "to be succeeded..." VIEW-AS ALERT-BOX. */
      assert_success().
/*      MESSAGE "succeeded..." VIEW-AS ALERT-BOX. */
      fCheckResponse(piRound).
   END.
   fLog("round end.").
END.



DEFINE STREAM sData.
FUNCTION fPerformRound RETURN LOGICAL (INPUT piRound AS INTEGER):
   DEFINE VARIABLE cLinex AS CHARACTER NO-UNDO.

   CURRENT-VALUE(OrderId) = 50 + piRound.
   CURRENT-VALUE(MemoSeq) = 400.  /* find out correct values */

   DEFINE VARIABLE cRoundFile AS CHARACTER NO-UNDO. 
   cRoundFile = "/apps/xfera/harrim/tmsrpc/test/unit/testdata/newton__add_whole_order_round" 
            + STRING(piRound) + ".txt".

   fLog("RoundFile: " + cRoundFile).
   INPUT STREAM sData FROM VALUE(cRoundFile).

   IMPORT STREAM sData UNFORMATTED cLinex.
   IMPORT STREAM sData UNFORMATTED cLinex.

  {/apps/xfera/harrim/tmsrpc/test/unit/newton__add_whole_order_initfromfile.i} 

   /* Initializing sequence / index field values for the round */
   IF piRound >= 4 THEN  giExpectedMsSeq = 501.

/*      MESSAGE gcExpectedTestDescription VIEW-AS ALERT-BOX. */
   fDispDescription(piRound).  
/*   MESSAGE "before add structs..." VIEW-AS ALERT-BOX. */
   fAddStructs().
/*   MESSAGE "before add struct data..." VIEW-AS ALERT-BOX. */
   fAddStructData(piRound).

/*   MESSAGE "before time... " VIEW-AS ALERT-BOX. */
   gdeExpectedCreStamp = fMakeTs().
/*   MESSAGE "Perform round... before call...." VIEW-AS ALERT-BOX. */
   call_add_whole_order().


/*   MESSAGE "Perform round... after call...." VIEW-AS ALERT-BOX. */
   fCheckResult(piRound).
/*   MESSAGE "Perform round... after check result..." VIEW-AS ALERT-BOX. */
   INPUT STREAM sData CLOSE.
END.

/*
/* PROCEDURE test_use_params0:
   fPerformRound(0).
END. */


PROCEDURE test_use_params1:
   fPerformRound(1).
END.


PROCEDURE test_use_params2:
   fPerformRound(2).
END.


PROCEDURE test_use_params3:
   fPerformRound(3).
END.


/* PROCEDURE test_use_params4:
   fPerformRound(4).
END. */


PROCEDURE test_use_params5:
   
   fPerformRound(5).

END.


PROCEDURE test_use_params6:
   fPerformRound(6).
END.


/* PROCEDURE test_use_params7:
   fPerformRound(7).
END. */


PROCEDURE test_use_params8:
   fPerformRound(8).
END.


PROCEDURE test_use_params9:
   fPerformRound(9).
END.


PROCEDURE test_use_params10:
   fPerformRound(10).
END.


PROCEDURE test_use_params11:
   fPerformRound(11).
END.


PROCEDURE test_use_params12:
   fPerformRound(12).
END.


PROCEDURE test_use_params13:
   fPerformRound(13).
END.


PROCEDURE test_use_params14:
   fPerformRound(14).
END.


PROCEDURE test_use_params15:
   fPerformRound(15).
END.


PROCEDURE test_use_params16:
   fPerformRound(16).
END.


PROCEDURE test_use_params17:
   fPerformRound(17).
END.


/* PROCEDURE test_use_params18:
   fPerformRound(18).
END.


PROCEDURE test_use_params19:
   fPerformRound(19).
END. */


PROCEDURE test_use_params20:
   fPerformRound(20).
END.


PROCEDURE test_use_params21:
   fPerformRound(21).
END.


PROCEDURE test_use_params22:
   fPerformRound(22).
END.


PROCEDURE test_use_params23:
   fPerformRound(23).
END.
*/

